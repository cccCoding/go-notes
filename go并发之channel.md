# go 并发之 channel

Go 语言最大的特色就是从语言层面支持并发。通过轻量的 goroutines 和 channel 可以简便地处理并发问题。

### channel

channel 是 goroutine 之间通信的管道，可以作为参数发送给其他 goroutine，从一端发送数据，另一端接收数据。

#### 声明

```go
var c chan int        // 声明了一个 nil 通道
c := make(chan int)   // 创建了一个可用通道，打印初始值是一个地址，类型是 chan int
```

#### 使用

一般将通道作为参数传递给函数或者方法实现两个协程之间通信。

对于无缓冲通道，通道操作默认是阻塞的，往通道里写数据之后当前协程便阻塞，直到其他协程将数据读出。一个协程被通道操作阻塞后，Go 调度器会去调用其他可用的协程，这样程序就不会一直阻塞。

#### 死锁

* 无缓冲通道只写数据或者读数据，当前协程阻塞，又没有其他可用的协程。
* 有缓冲通道已满，再往通道中写数据，当前协程阻塞，又没有其他可用的协程。
* 空 select 语句`select {}`，没有 case 分支，所以便一直阻塞引起死锁。

#### 关闭

可以用内置函数`close(ch)`关闭通道，通道关闭后数据不能再传输。

**判断通道已关闭**

* 数据接收方可以通过返回状态判断通道是否已关闭：

  ```go
  val, ok := <- ch
  ```

  ok 用于判断 ch 是否已关闭且没有缓冲值可以读取。为 true，该通道还可以进行读写操作；为 false，通道已关闭且没有缓冲数据，不能再进行数据传输，返回的对应类型的零值。

* for range 读取通道，通道关闭，for range 自动退出

  ```go
  for v := range ch {
  	fmt.Println(v)
  }
  ```

  应注意，使用 for range 读取一个通道，数据写入完毕后必须关闭通道，不然发生死锁。

#### 缓冲通道和通道容量

之前创建的通道是无缓冲的，读写通道会立马阻塞当前协程。对于缓冲通道，写不会阻塞当前通道直到通道满了，同理，读操作也不会阻塞当前通道除非通道没数据。

无缓冲的 channel 是同步的，而有缓冲的 channel 是异步的。

```go
ch := make(chan type, capacity)
```

capacity 是缓冲大小，必须大于 0。内置函数 len()、cap() 可以计算通道的长度和容量。

如果缓冲通道是关闭状态但有数据，仍然可以读取数据。

#### 单向通道

主要用在通道作为参数传递的时候，Go 提供了自动转化，双向转单向。

使用单向通道主要是可以提高程序的类型安全性，程序不容易出错。

#### 常见异常操作

* 往一个 nil channel 发送数据，会造成阻塞。

* 往一个 nil channel 接收数据，会造成阻塞。

  `v, ok := <-ch` ，如果 ch 的值为 nil，即使是两个返回值的形式，读取操作也是阻塞的。

* 往一个已经关闭的 channel 发送数据，会引起 panic。

* 从一个已经关闭的 channel 接收数据，返回已缓冲数据或者零值。

* 使用 for range 读取一个通道，数据写入完毕后必须关闭通道，不然发生死锁。

* 有方向的 channel 不可以被关闭。

channel的数据结构、源码，为什么它可以做到线程安全？todo

channel 是怎么通过注册相关 goroutine id 实现消息通知的。


