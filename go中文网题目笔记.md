## 常见题

### defer

公众号 Golang来啦 《5年Gopher都不知道的defer细节》
1：当函数返回时，执行defer语句。因此可以用来做资源处理。
2：多个defer语句，按先进后出方式执行。
3：defer语句中的变量，在defer声明时就决定了。
常见面试题要记住！！！ return xxx 这条语句并不是一个原子指令，经过编译之后编成三条指令：1，返回值=xxx；2，调用defer函数；3，空的return。需要注意的时defer语句里会不会改变返回值。

### 循环问题

for k,v range slice ，v是for循环内的局部变量。slice是副本，要注意循环数组和切片的区别。
for i := range slice {slice = append(slice, i)} ，不会出现死循环，能正常结束。range表达式是副本参与循环，因此参与循环的是slice的副本，循环内改变切片长度不影响循环次数，如有使用value的操作也是副本中的value，数组的副本是另一个数组，切片的副本其指向的底层数组还是原来那个。

### init函数问题

init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等。
一个包甚至一个源文件中可以出现多个init函数。
同一个包中多个init函数的执行顺序没有明确定义，不同包init函数的执行顺序由包导入的依赖关系决定，从依赖的最顶层到最底层。
一个包被引用多次也只初始化一次。
引入包不可出现死循环。todo：解决循环导包的常见思路。
init函数在代码中不能被显示调用，不能被引用。

### 值类型和引用类型

值类型：基本数据类型int、float、bool、string以及数组和struct。值类型变量直接存储，内存通常在栈中分配。

引用类型：指针、slice、map、chan、interface等。引用类型变量存储的是一个地址，这个地址存储最终的值，内存通常在堆上分配，通过GC回收。

### 指针和引用

todo 
都用来让一个变量提供对另一个变量的访问。Java支持引用。
不同：
    指针变量存储的是另一个变量的地址。引用变量指向另一个变量。
    指针可以重新分配，而引用不能。
go里面引用类型的值打印出来是一个地址。

### 接口

​    todo：interface的源码实现，内部结构等

    静态类型、动态类型和动态值
    变量的类型在声明时指定、且不能改变，称为静态类型。接口类型的静态类型就是接口本身。接口没有静态值，它指向的是动态值。接口类型的变量存的是实现接口的类型的值，该值就是接口的动态值，该值的类型就是接口的动态类型。
    当我们访问接口类型的时候，返回的是底层动态值的类型。
    
    nil接口值
    当且仅当动态值和动态类型都为nil时，接口类型变量的值才为nil。
    
    空接口interface{}
    一个不包含任何方法的接口，称之为空接口，形如：interface{}。因为空接口不包含任何方法，所以任何类型都默认实现了空接口。函数参数为interface{}时可以接收任何类型的参数，包括指针类型（而不是使用*interface{}）。
    
    类型断言
    类型断言可以用来获取接口的底层值，i.(Type)，其中i是接口，Type是类型或接口。编译时会自动检测i的动态类型与Type是否一致。如果Type未实现接口i，编译时报错；或者i的动态值不是Type，则会报panic错误。可使用 value, ok := i.(Type) 两个返回值语法，go会自动检查上面提到的两种情况，我们只需要通过变量ok判断结果是否正确即可。如果动态类型不存在（i的动态类型为interface{}），则断言总是失败（第二个返回值为false）。
    
    类型选择
    switch i.(type) {}，其中i是接口，type是关键字，只有接口才可以使用类型选择，将接口的具体类型与各种case语句中的类型进行匹配比较。
    
    接口嵌套
    go语言中，接口不能去实现别的接口也不能继承，但是可以通过嵌套接口创建新接口。
    type Math interface {
        Shape
        Object
    }
    type Shape interface {
        Area() float32
    }
    type Object interface {
        Perimeter() float32
    }
    通过嵌套接口Shape和Object，创建了新接口Math。任何类型如果实现了接口 Shape 和 Object 定义的方法，则说类型也实现了接口 Math。

### 方法与函数

#### 函数

​    func methodName(...Type) Type {...} ，函数定义。
​    函数的入参支持可变参数列表，但必须是入参的最后一个。
​    函数参数只有值传递，没有引用传递，即全部需要重新拷贝变量。可通过传递指针或者引用类型实现引用传递的效果。
​    函数也是一种类型，函数不能重载（函数名相同，入参等不同）。
​    内建函数
​        new和make
​            new(T)和make(T,args)是Go语言内建函数，用来分配内存，但适用的类型不一样。new为T类型的新值分配已置零的内存空间，并返回地址*T，适用于值类型，如int、数组、结构体等。make得到的是初始化之后的T的引用，用来分配引用类型，只适用于slice、map和channel。
​            通过make创建的切片可以copy，其他方式不行。通过make创建的map是空map，通过字面量形式创建的map是nil，切片同理。
​            使用make创建map变量时可以指定第二个参数，不过会被忽略。
​        cap和len
​            cap返回容量，len返回长度。
​            cap适用于数组、数组指针、slice和channel。不适用与map。
​            可以用len返回map的元素个数。
​        close 
​            主要用来关闭channel。
​        append
​            用来追加元素到数组、slice中。
​        panic和recover 
​            用来做错误处理。 todo：panic，recover，defer。
​            当协程！遇到panic时，会遍历该协程的defer并执行（执行顺序是先进后出），如果在defer执行的过程遇到recover则停止panic，返回recover继续向下执行，没有遇到recover，遍历完defer，然后向stderr抛出panic信息。执行第一个defer出现异常，顺序执行下一个defer？

#### 方法

​    func (receiver Type) methodName(...Type) Type {...} ，定义方法和函数类似，区别在于方法定义时，在func和方法名之间会增加一个额外的参数。(receiver Type)是额外增加的参数，receiver称为接收者，Type可以时任意合法的类型。可以说，方法methodName属于类型Type。
​    必须保证类型和其方法定义在同一个包里。如果做不到，可以创建类型别名。
​    每个方法声明的时候，编译器会各自声明相对应的隐式函数。

    值接收者方法和指针接收者方法
    方法的接收者是副本。值接收者和指针接收者方法最大区别在于，在方法中修改指针接收者的值会影响到调用者的值，而值接收者不会。一个是值的副本，一个是指针的副本，指针的副本指向的还是原来的值。
    方法集：一组关联到自定义类型的值或指针的方法。一个自定义类型T的方法集仅包括它的值方法，该类型的指针类型*T的方法集包括所有值方法和指针方法。
    调用指针接收者方法也可以写成值调用 a.A() ，编译器会自动帮我们转成指针调用 (&a).A() ，以满足接收者的要求。调用值接收者方法也可以写成指针调用，因为值接收者方法属于该类型的指针类型*T的方法集。
    因此，值接收者的方法可以使用值或者指针调用。对于指针接收者的方法，用一个指针或者一个可取得地址的值来调用都是合法的。
    一种情况，函数返回的空结构体 T{} 不可寻址，不可寻址的结构体不能调用该结构体指针接收者的方法。要保证可寻址的结构体才可以调用该结构体指针接收者的方法。
    根据场景考虑使用值接收者还是指针接收者。如在方法中发生的变化对调用者可见或变量拷贝成本高，应考虑使用指针接收者。其他情况建议使用值接收者。
    不能用多级指针调用方法。
#### 区别

方法与函数的区别：方法属于某一种类型，且有接收者。
为什么有了函数还需要方法？
    1，Go不是纯粹的面向对象的语言且不支持类，通过类型的方法可以实现和类相似的功能，又不会像类那样显得很“重”；
    2，同名的方法可以定义在不同的类型上，但是函数名不允许相同。

### ...的使用

​    1，放函数入参最后作为可变参数。切片传入可变参数函数时加上...。
​	2，var arr = [...]int{1,2,3,4,5} 编译器会自动确定数组长度。
​	3，var a = []int{1,2,3}; var b = []int{4,5,6}; a = append(a, b...)	，就不用for range去append了。

### select使用

​    select机制用来处理异步IO问题，每个case语句里必须是一个IO操作。
​    有可执行的case则执行，多个可执行则随机选择一个可用通道做收发操作。所有case都阻塞且没有default，则阻塞。所有case都阻塞且有default，执行default。select{} 空select会导致阻塞。
​    case分支中如果channel为nil，该分支会被忽略。
​    case <-time.After(time.Second): 超时执行。

### context使用

定义，原理

使用方法

常见使用场景：超时控制，保存全局信息。

### 声明和赋值问题

单变量声明 x := 1 用于声明之前未声明过的变量x，并赋值为1。
当多值声明时，x, y := 1, 2 左边的变量有一个是新声明的就可以。如果新变量x与同名已定义的变量x不在同一个作用域中，那么go会重新定义这个变量。
多重赋值 j = 1; i，s[j-1] = 1，"a" ，分为两个步骤，有先后顺序：
    1，首先计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式
    2，赋值
    所以上面赋值实际先计算索引j-1的值，然后执行赋值操作 i, s[0] = 1, "s"
data.result, err := work() 出错，:= 操作符不能用于结构体字段赋值，应修改为 var err error; data.result, err = work() 即用赋值的方式。
字面量初始化数组、slice和map时，最好是在每个元素后面加上逗号，即使是声明在一行或者多行都不会出错。如 x := []int{1,2,}
对于类似 x = y 的赋值操作，必须知道x的地址，才能够将y的值赋给x。map的value不可寻址，所以不能赋值。

### 常量问题

​    常量无法使用&取址。
​    常量声明组中如不指定类型和初始化值，则与上一行非空常量相同。
​    iota的使用
​        https://www.cnblogs.com/zsy/p/5370052.html
​        iota是golang的常数计数器，只能在常量的表达式中使用。iota在const关键字出现时将被重置为0，const中每新增一行常量声明将使iota计数一次。

### string、byte和rune

​    byte是uint8的别名，rune是int32的别名，别名之间可直接转换。

    string
    go语言中字符串是只读的字节切片。
    string类型变量不能赋值为nil。空值为 "" 。也不能判断是否与nil相等(if s == nil {})。
    s := "hello" ; r := []rune(s) ，将字符串转成rune切片。

### 输入输出问题

​    如果类型实现String()方法，当格式化输出的时候会自动使用String()方法。
​    格式化输出时 i:=-5; fmt.printf("%+d",i);  其中 %d 表示输出十进制数字，+ 表示输出数值的符号

### 比较问题

go中不同类型不能进行比较。
map、slice和function属于不可比较类型，只能判断是否为nil。
数组长度是数组类型的一部分，不同长度的数组为不同类型，不能进行比较。
结构体比较问题
    结构体只能比较是否相等，且相同类型的结构体才能进行比较。结构体是否相同不但与属性类型有关，还与属性顺序有关。
    结构体可比较的前提是所有成员变量的类型均可比较。
    如果struct的所有成员都可以比较，可通过==或！=比较是否相等，比较时逐个项进行比较，如果每一项都相等，则两个结构体相等。

### nil值问题

nil只能赋值给指针、channel、function、interface、map或slice类型的变量。
var x = nil 会导致编译错误，因为nil为上述类型的零值，如果不指定变量类型，编译器猜不出来变量的具体类型，导致编译错误。

### 一些代码编译合规规则

函数中声明的变量必须要使用，但可以有未使用的全局变量。函数的参数未使用也是可以的。常量声明但未使用是能通过编译的，常量编译后是一个简单值的标识符。
导入的包如果未使用，代码不能通过编译。如果需要导入包又不想使用，可以用 _ "fmt" 使通过编译。
只有 i++ i-- 形式的自增自减，且只能作为独立语句，不能作为表达式。

### 面对对象式编程

Go语言中的“继承”和多态。Go语言没有继承，但是可以通过组合（嵌入）的方式实现代码的复用。
嵌入类型，将已有的类型直接声明在新的结构类型里。通过嵌入，内部类型的属性、方法可以为外部类型所用。此外，外部类型还可以定义自己的属性和方法，甚至和内部类型相同的方法，这样内部类型的方法就会被“屏蔽”。如果内部类型实现接口A，可以认为外部类型也实现了接口A。
假设外部结构体类型是 S，内部类型是 T，则关于内部类型的方法提升如下规则：
    T 嵌入 S，外部类型 S 可以通过值类型或指针类型调用内部类型 T 的值方法；
    T 嵌入 S，外部类型 S 只能通过指针类型调用内部类型 T 的指针方法；
    *T 嵌入 S，外部类型 S 可以通过值类型和指针类型调用内部类型 T 的值方法和指针方法；
总结成一句话：不管是 T 嵌入 S，还是 *T 嵌入 S，外部类型 S 唯独通过值类型不能调用内部类型 T 的指针方法外，其他情况下内部类型 T 的方法都可以获得提升，即可被外部类型 S 访问。

### 闭包

todo 

### go build, go install 和 go get

go build : 编译出可执行文件

go install : go build + 把编译后的可执行文件放到GOPATH/bin目录下

go get : git clone + go install

直接 get get 如果失败，可以 git clone + go install







go语言中文网公众号 面试题day61
19 锁失效，应该data指针作为test()的方法接收者



