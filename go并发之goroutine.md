# go并发编程之 goroutine

Go 语言最大的特色就是从语言层面支持并发。通过轻量的 goroutines 和 channel 可以简便地处理并发问题。

## goroutine

goroutine 是 Go 语言实现的用户态线程，主要用来解决操作系统线程太“重”的问题。

#### 进程

进程通信需要利用各种模式的 IPC（进程间通信），如信号量，消息队列，管道等。

#### 线程

线程是可以在 OS 中执行的最小处理单元。

线程存在于某个进程中，进程可以包含多个线程。

线程之间共享内存。因此线程间通信比进程之间通信更加简单。

线程太“重”表现在一下两个方面：

1. 创建和切换太重：操作系统线程需要进入内核，而进入内核所消耗的性能开销较大。
2. 内存使用太重：内核在创建操作系统线程时为避免极端情况下操作系统线程栈的溢出，默认为其分配一个较大的栈内存，通常会导致浪费，且栈内存空间一旦创建和初始化之后大小不能改变，某些特殊场景下系统线程栈还是有溢出的风险。

线程变慢原因：

* 线程自身有一个很大的堆（大于等于1MB）占用了大量内存。
* 创建线程消耗太大。
* 线程需要重复存储许多寄存器，这会降低应用程序性能。
* 线程创建和消除是操作系统级别操作，这一操作较慢。

#### 协程

goroutine 并不是轻量级线程，它依赖于线程运行。goroutines 是 Golang 中执行并发任务的方式。他们仅存在于 go 运行时的虚拟空间中而不在于 OS 中，因此需要 go 调度器来管理他们的生命周期。要记住对于所有操作系统看到的都只有一个请求并运行多个线程的单个用户级进程。goroutine 由 GoRuntimeScheduler 管理。

为了使运行时的堆栈更小，新创建的 goroutine 只分配几 kb 的空间，如果不够，运行空间自动增长（或者缩小）内存来实现堆栈的管理，从而让大部分 goroutine 存在于适量的内存中。

#### 协程调度

MPG 调度模型，两级线程模型

M，P，G，Schedt 四个重要结构

https://segmentfault.com/a/1190000018150987

https://www.cnblogs.com/wdliu/p/9272220.html

#### 其他面试题

1. 什么是 goroutine；他与 process， thread 有什么区别；
2. goroutin 的调度，什么是抢占式goroutine调用；
3. 僵尸进程和孤儿进程；
4. 协程通信 channel，mutex
5. 怎样停止一个 goroutine，怎么实现协程完美退出

#### 面试总结版本

Go 语言通过轻量级的 goroutine 和 channel 来简便地处理并发问题，从语言层面支持并发。goroutine 是 Go 语言实现的用户态线程，主要用来解决操作系统线程太“重”的问题。

因为操作系统线程是内核层去操作的，性能开销大。且内核在创建操作系统线程的时候给其分配的内存较大且固定，造成浪费，极端情况下还有溢出风险。

相比于操作系统线程，goroutine 要轻量得多。goroutine 是用户态线程，存在于 Go 运行时的虚拟空间中而不在于 OS 中，通过 Go 调度器来管理他们的生命周期。其创建和切换都在用户代码中完成而无须进入操作系统内核，性能开销小。且 goroutine 启动时默认栈大小只有 2 kb，还可以动态扩大收缩，既避免浪费，又没有栈溢出风险。

所以 Go 程序中可以创建成千上万个 goroutine 并发执行任务而不用太担心性能和内存问题。

goroutine 建立在操作系统线程基础之上，它与操作系统线程之间实现了一个多对多 (M:N) 的两级线程模型。这里 M:N 指 M 个 goroutine 运行在 N 个操作系统线程之上，内核负责对这 N 个操作系统线程进行调度，而这 N 个系统线程又负责对这 M 个 goroutine 进行调度和运行。

所谓的对 goroutine 的调度，指程序代码按照一定算法在适当的时候选出合适的 goroutine 并放到 CPU 上去运行的过程，负责对 goroutine 进行调度的程序代码称之为 goroutine 调度器。

MPG 调度模型，两级线程模型

包含 M，P，G，schedt 四个重要结构

* G 结构体。保存了 goroutine 的所有信息，该结构体的每个实例都代表了一个 goroutine，调度器代码可以通过 G 对象来对 goroutine 进行调度。

* schedt 结构体。保存调度器自身的状态信息和 goroutine 的全局运行队列。每个 Go 程序只有一个调度器，即 schedt 结构体只有一个实例对象，该实例对象在源代码中被定义成了一个共享的全局变量，这样每个工作线程都可以访问它以及它的 goroutine 运行队列，我们成这个队列为全局运行队列。

* P 结构体。用于保存工作线程执行go代码时所必须的资源，goroutine 的运行队列等。即除全局运行队列外，每个工作线程有一个私有的局部 goroutine 运行队列，工作线程优先使用自己的局部运行队列，必要时才去访问全局运行队列，减少锁冲突，提高性能，提高工作线程的并发性。局部运行队列被包含在 P 结构体的实例对象之中，每一个运行着 go 代码的工作线程都会与一个 P 结构体的实例对象关联在一起。

* M 结构体。代表工作线程。每个工作线程都有唯一一个 M 结构体的实例对象与之对应，M 对象记录着工作线程的栈起始位置、当前正在执行的 goroutine 以及是否空闲等信息，还通过指针维持着和 P 结构体的实例对象之间的绑定关系。通过 M 可以找到与之对应的工作线程正在运行的 goroutine，还可以找到工作线程的局部运行队列等资源。

 ![image-20210224143444973](goroutine协程.assets/image-20210224143444973.png)

上图中圆形图案代表 g 结构体的实例对象，三角形代表 m 结构体的实例对象，正方形代表 p 结构体的实例对象，其中红色的 g 表示 m 对应的工作线程正在运行的 goroutine，而灰色的 g 表示处于运行队列之中正在等待被调度起来运行的 goroutine。

从上图可以看出，每个 m 都绑定了一个 p，每个 p 都有一个私有的本地 goroutine 队列，m 对应的线程从本地和全局 goroutine 队列中获取 goroutine 并运行之。

参考链接：

https://www.cnblogs.com/abozhang/p/10802319.html

## 并发编程

### 并行与并发

并行就是同时执行，在某一时间点能执行多个任务。并行需要借助多线程或多进程。

并发是在某一时间段内可以同时处理多个任务。通常说程序是并发设计的，就是说它允许多个任务同时执行，这个同时指的就是一段时间内。单线程中多个任务以间隔执行方式实现并发。

### 并发之协程 goroutine

协程（Goroutine）可以理解成轻量级的线程，Go 应用程序通常能并发地运行成千上万的协程。Go 语言的协程可以理解为线程之上的一个包装器，由 Go 运行时管理而不是操作系统。Go 运行时负责给协程分配和回收资源。

#### 创建协程

Go 创建一个协程非常简单，只要在方法或函数调用之前加关键字 go 即可。

```go
func printHello() {
    fmt.Println("hello world goroutine")
}

func main() {
    go printHello()     // 创建协程
    go func() {			// 创建匿名协程
3        fmt.Println("hello world goroutine 2")
4    }()
    fmt.Println("main goroutine")
}
```

上面代码，使用 go 关键字创建了两个协程，因此现在包括主协程一共有三个协程。多个协程并发执行。主协程执行完毕，程序便退出，其他协程随即也退出。
