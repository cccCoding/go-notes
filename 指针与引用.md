# 指针和引用

引用和指针非常相似，它们都用来让一个变量提供对另一个变量的访问。

## 引用

需要从类型和传递两个角度分别看待引用。

* 从类型角度，类型可分为值类型和引用类型，一般而言，我们说到引用，强调的都是类型。
* 从传递角度，有值传递、址传递和引用传递，传递是在函数调用时才会提到的概念，用于表明实参与形参的关系。

### 什么是引用

引用的实现主要有两种。

1. C++ 的实现，引用其实一种便于使用指针的语法糖，是某块内存的别名，对已存在的变量可以声明别名，这种别名称为引用变量。
2. Python 中的实现，本质是底层结构中包含指向实际内容的指针。

### 参数传递

参数传递有值传递、址传递和引用传递。

#### 值传递

函数调用时，实参通过拷贝将自身内容传递给形参，形参实际上是实参值的一个拷贝，此时，针对函数中形参的任何操作，仅仅是针对实参的副本，不影响原始值的内容。

#### 址传递

值传递中有一个特殊形式，如果传递参数的类型是指针，我们就会称之为址传递。

#### 引用传递

实参地址在函数调用被传递给形参（即实参和形参拥有相同地址），则可以认为是引用传递。此时，针对函数中形参的操作会影响到实参。

C++ 支持引用传递。

### Go 语言是值传递

```go
func fn(m map[int]int) {
	fmt.Printf("fc: %p\n", &m)
	m = make(map[int]int)
	fmt.Printf("fn:%v\n", m == nil)
}

func main() {
	var m map[int]int
	fmt.Printf("main: %p\n", &m)
	fn(m)
	fmt.Printf("main:%v\n", m == nil)
}
```

输出如下：

```
main: 0xc000006028
fc: 0xc000006038
fn:false
main:true
```

通过打印信息可以看到，实参和形参地址不同，且对形参赋值不影响实参。因此，**Go 语言没有引用传递。**

而址传递可以看做值传递中的一个特殊形式，因此可以说，**Go 语言是值传递。**

### Go 引用类型

如果按照 C++ 中引用的实现机制，则 **Go 语言没有引用变量**，Go 程序中定义的每个变量都占用一个唯一的内存位置。创建两个共享同一内存位置的变量是不可能的。可以创建两个指向同一内存位置的变量，不过这与两个变量共享同一内存位置是不同的。

如果按照 python 中引用的实现机制，即结构体中包含指针成员。对类型进行分类：

* 值类型：基本数据类型 int、float、bool、string 以及数组和 struct。值类型变量直接存储值，内存通常在栈中分配。

* 引用类型：指针、slice、map、chan、interface、function。引用类型变量存储的是一个地址，这个地址存储最终的值，内存通常在堆上分配，通过 GC 回收。引用类型都可以用 nil 进行赋值。

#### slice、map 和 channel 的底层实现

slice、map 和 channel 的实现机制是结构体中包含指针成员。它们都可以使用内置函数 make 进行初始化。

**map**

map 实际是指向 runtime.hmap 结构体的指针。

当我们写如下代码时

```go
m := make(map[int]int)
```

编译器会自动去调用 runtime.makemap

```go
func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap
```

从 runtime.makemap 返回的值的类型是指向 runtime.hmap 结构体的指针。

那么如果 map 是指针，那是不是应该这样表示 *map[key]value ？事实是编译器将类型从 *map[int]int 重命名为 map[int]int 。

**channel**

也是 runtime 类型的指针。

**slice**

slice 的结构包含三个成员，分别是切片的底层数组地址、切片长度和容量大小。

```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

## 指针

### 什么是指针

计算机内存可以看做一串单元格，每个单元格都有一个地址，是其所在的内存位置，每个单元格存储一个值。如果你知道某个单元格的内存地址，就可以访问该单元格并更新或读取里面的内容。而 CPU 所做的一切都是为获取和存储值到内存单元中。

在代码中，通过变量就可以操作存储在内存中的值，变量只是一个由数字字母组成的、标识存储位置的假名，由编译器为变量分配唯一的内存地址。一个变量对应了一段内存空间，这段内存空间存储了该变量对应类型的值。

指针变量的值是另一个变量的内存地址。通过指针，就可以更新或读取另一个变量的值，而不需要用到变量名。

对于每一种类型，不管是自定义的还是 Go 语言内置的，都有相应的指针类型。例如内置类型 int，对应的指针类型是 *int。如果你自己声明了类型 User，对应的指针类型就是 *User。

所有的指针类型有相同的特点。首先，它们以 * 符号开头；其次，占用相同的内存空间并且都表示一个地址，使用 4 个（32 位机器）或 8 个字节（64 位机器）长度表示一个地址。

设计指针的目的是实现函数间值共享，即使该值不在函数自己栈帧里，也能对其进行读写操作。

与其他变量相比，指针变量并没有特别之处，因为它们也是变量，有内存地址和值。

### 底层原理

[《栈与指针》](https://mp.weixin.qq.com/s/5SnF2V5satUL9-I4zr_LxQ)

### 指针的声明和使用

指针由 * 操作符和存储值的类型表示。

`*`也用于指针变量的解引用，使得我们可以访问指针指向的值。

```go
var i int = 10			// 声明int类型变量i，初始值10
var ptr *int = &i 		// 声明指针变量ptr，初始值为i的地址。& 操作符用于获取变量的地址。
fmt.Println(ptr, *ptr)	// *ptr对应指针指向的变量的值 0xc000018060 10 

*ptr = 12               // 更新指针指向的变量的值，实际是指针变量解引用，将结果存储在 i 指向的内存位置
fmt.Println(*ptr, i)    // 12 12
```

`*int`类型的指针，指向的必须是 int 类型变量的地址，若指向其他类型变量地址，编译报错。

```go
str := "go"
var ip *int
ip = &str	// cannot use &str (type *string) as type *int in assignment
```

### 空指针

一个指针已声明而没有赋值时，称为空指针，值为 nil。任何类型的指针的零值都是 nil。

```go
var ip *int
fmt.Println(ip)                  	// nil
fmt.Printf("ip 的值为:%x", ip)       // ip 的十六进制的值为:0
```

### 指针相等判断

指针之间也是可以进行相等判断的，只有当它们指向同一个变量或全部是 nil 时才相等。

### 指针作为函数参数使用

```go
func a(p *int) {
    *p++
}

func main() {
    i := 10
	a(&i)
	fmt.Println(i)  // 打印11，a函数中的指针p指向main函数中的i的内存位置
}
```

### new 函数创建指针

内建函数 new 也是一种创建指针的方法。`new(type)`表示创建一个 type 类型的匿名变量，初始化为 type 类型的零值，并返回变量的指针，指针类型为 *type。new 适用于“值类型”，如 int、数组、结构体等。

```go
p := new(int)       // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p)     // 0
*p = 2              // 设置 int 匿名变量的值为 2
fmt.Println(*p)     // 2
```
