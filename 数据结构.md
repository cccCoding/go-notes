## 数据结构

### 数组

​    数组是一组特定长度的连续存储空间。
​    数组，同一种数据类型的固定长度的序列，长度是数组类型的一部分，var a [5]int 和 var a [10]int 是不同的类型。
​	数组是值类型，改变副本的值不会改变本身的值。

### slice

​    切片是数组的一个引用，底层是数组，是引用类型，长度可变。
​    声明时指定长度是数组，声明时不指定长度是切片。切片声明后 var s []int 默认初始化零值是nil，不是空数组。可以使用append()函数为刚声明的为nil的切片增加元素。
​    切片的内部实现中有三个变量，指针ptr，个数len和容量cap，其中ptr指向真正的数据存储地址（数组）。
​    a := [5]int{1,2,3,4,5}; t := a[3:4:4]   截取数组（切片）可以创建新的切片，包左不包右。假设a的容量为k，得到的切片长度为j-i，容量为k-i。上面第三个参数用来限制新切片的容量，但不能超过原数组（切片）的底层数组大小。基于数组创建的切片是原始数组的视图。
​    index访问切片元素和len有关，[i:j]创建新切片与原切片cap有关。

### map

​    map存储的是无序的键值对集合。
​    map的key是可以用 == 做比较的类型，value类型没有限制。
​    map就是底层hash表的引用？
​    往 var m map[string]int 声明后的nil map m写数据会导致panic，应使用make函数为其初始化。
​    获取一个map中不存在的键值对时，返回值类型的零值。可以 if _, ok := map[key]; ok {} 判断键值是否存在。
​    delete(map, key) map不存在的键值对时不报错，相当于没操作。判断删除是否成功可通过键值是否还存在判断。
​    map是引用类型，和副本共享底层数据。这一点和slice相似。要得到一个不共享底层数据的map副本，可以创建新map，迭代旧map给新map的键值对数据赋值。
​    map不是并发安全的，并发操作加上锁。也可以sync包下的Map，是并发安全的。

### Mutex

​    sync包下，提供Lock和Unlock方法，所有在Lock和Unlock之间的代码都只能由一个goroutine执行，避免竞态条件。如果一个协程已经持有了锁（Lock），其他协程试图获得该锁时，协程会被阻塞，直到Mutex解除锁定。
​    还可以用容量为1的channel处理竞态条件。

### RWMutex

​    读写锁。RWMutex基于Mutex，在Mutex的基础上增加了读、写的信号量，使用了类似引用计数的读锁数量。Lock和Unlock方法用于申请和释放写锁，RLock和RUnlock用于申请和释放读锁。
​    读写锁适合读多写少的场景。
​    读锁与读锁兼容，读锁与写锁互斥，写锁和写锁互斥，在锁释放后才可以继续申请互斥的锁：
​        可以同时申请多个读锁。
​        有读锁时申请写锁将阻塞，有写锁时申请读锁将阻塞。
​        只要有写锁，申请读锁和写锁都将阻塞。
​    无论时Mutex还是RWMutex都不会和goroutine进行关联，可以在一个goroutine申请锁，在另一个goroutine释放锁。

### channel

​    声明方式一 var c chan int ，声明了一个nil channel。
​    c := make(chan int)，创建了一个可用的channel，打印其类型是 chan int，其值是一个地址。
​    给一个nil channel发送数据，造成永远阻塞；从一个nil channel接收数据，造成永远阻塞。
​    给一个已经关闭的channel发送数据，引起panic；从一个已经关闭的channel接收数据，返回已缓冲数据或者零值。
​    v, ok := <-ch ，如果ch为nil，即使是两个返回值的形式，读取操作也是阻塞的。ok用于判断ch是否已关闭且没有缓冲值可以读取。为true，该channel还可以进行读写操作，为false，channel已关闭且没有缓冲数据不能再进行数据传输，返回的v为零值。
​    内置函数 close(ch) 关闭channel。
​    只发送channel和只读取channel主要用在channel作为参数传递的时候，提高程序的类型安全性。有方向的channel不可以被关闭。
​    for range 读取channel，channel关闭，for range自动退出，需要注意发送完毕后必须close，不然死锁。