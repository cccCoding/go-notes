## 数据结构

### 数组

数组是一组特定长度的连续存储空间。是同一种数据类型的固定长度的序列。

长度是数组类型的一部分，不同长度的数组是不同的类型。

数组是值类型，改变其副本的值不会改变本身的值。

### slice

切片是数组的一个引用，底层是数组。引用类型，长度可变。

声明时指定长度的是数组，声明时不指定长度的是切片。

`var s []int` 声明的切片初始化值是 nil，通过 make 创建了一个可用的空切片，初始化值是一个地址。

使用 append 函数可以为刚声明的为 nil 的切片增加元素。

切片的内部实现中有三个变量，指针 ptr，个数 len 和容量 cap，其中 ptr 指向真正的数据存储地址（数组）。

**截取**

```go
a := [5]int{1,2,3,4,5}
t := a[3:4:4]
```

截取数组（切片）可以创建新的切片，包左不包右。上面第三个参数用来限制新切片的容量，但不能超过原数组（切片）的底层数组大小。基于数组创建的切片是原始数组的一个视图。

index 访问切片元素和 len 有关，`t := a[i:j]` 创建新切片与原切片 cap 有关。

### 数组和切片的区别



### map

map 存储的是无序的键值对集合。

map 的 key 必须是可以做相等比较的类型，value 类型没有限制。

map 是引用类型，和副本共享底层数据，这一点和 slice 相似。要得到一个不共享底层数据的 map 副本，可以创建新 map，迭代旧 map 给新 map 赋值。

map 不是并发安全的，并发操作要加上锁。也可以 sync 包下的 Map，是并发安全的。

map 就是底层 hash 表的引用？

`var m map[string]int` 声明的 map，初始值为 nil。往值为 nil 的 map 写数据会导致 panic，应使用 make 函数为其初始化。

`a := map[key]` 获取一个 map 中不存在的键值对时，返回值类型的零值。

可以通过 `if _, ok := map[key]; ok {}` 判断键值对是否存在。

`delete(map, key)` 删除键值对，当 map 不存在的相应的 key 时，不报错，相当于没操作。通过键值对是否还存在来判断删除是否成功。

定义 map：

1. 不推荐，map[string]Student，map 的 value student 的属性是不可以修改的
2. 推荐，map[string]*Student，map 的 value student 的属性是可以修改的，且效率高

### channel

初始化

* `var c chan int` 声明的 channel 初始化值为 nil。
* `c := make(chan int)` ，创建了一个可用的 channel，初始化值是一个地址，打印其类型是 chan int。

无缓冲的channel是同步的，而有缓冲的channel是异步的

注意：

* 给一个 nil channel 发送数据，造成永远阻塞；从一个 nil channel 接收数据，造成永远阻塞。
* 给一个已经关闭的 channel 发送数据，引起 panic；从一个已经关闭的 channel 接收数据，返回已缓冲数据或者零值。
  `v, ok := <-ch` ，如果 ch 的值为 nil，即使是两个返回值的形式，读取操作也是阻塞的。ok 用于判断 ch 是否已关闭且没有缓冲值可以读取。为 true，该 channel 还可以进行读写操作，为 false，channel 已关闭且没有缓冲数据不能再进行数据传输，返回的 v 为零值。
* 内置函数 `close(ch)` 可关闭 channel。
* 单向 channel：只发送 channel 和只读取 channel 主要用在 channel 作为参数传递的时候，提高程序的类型安全性。有方向的 channel 不可以被关闭。
* for range 读取 channel，channel 关闭，for range 自动退出。需要注意发送完毕后必须 close，否则会造成死锁。
* 怎样判断 channel 已经关闭了。

### Mutex

锁，sync 包下，提供 Lock 和 Unlock 方法，所有在 Lock 和 Unlock 之间的代码都只能由一个 goroutine 执行，避免竞态条件。如果一个协程已经持有了锁（Lock），其他协程试图获得该锁时会被阻塞，直到 Mutex 解除锁定（Unlock）。

可以用容量为 1 的 channel 处理竞态条件。例子：todo

### RWMutex

读写锁。RWMutex 基于 Mutex，在 Mutex 的基础上增加了读、写的信号量，使用了类似引用计数的读锁数量。Lock 和 Unlock 方法用于申请和释放写锁，RLock 和 RUnlock 方法用于申请和释放读锁。

读写锁适合读多写少的场景。

读锁与读锁兼容，读锁与写锁互斥，写锁和写锁互斥。在锁释放后才可以继续申请互斥的锁：

* 可以同时申请多个读锁。
* 有读锁时申请写锁将阻塞，有写锁时申请读锁将阻塞。
* 只要有写锁，申请读锁和写锁都将阻塞。

无论时 Mutex 还是 RWMutex 都不会和 goroutine 进行关联，可以在一个 goroutine 申请锁，在另一个 goroutine 释放锁。