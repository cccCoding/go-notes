# go 常见面试题

https://www.zhihu.com/question/60952598?sort=created

## 语言比较

golang 与 java 比较，有点和缺点，自己的理解。

#### VM

#### 协程支持

#### 面向对象/多态

#### 接口

#### 泛型

#### 使用场景

## 数据结构

详见《数据结构.md》

## 技术原理

### defer

公众号 Golang来啦 《5年Gopher都不知道的defer细节》

panic/defer/recover这些都要知道，以及defer对return暂存区的影响需要理顺；

1. 当函数返回时，执行 defer 语句。通常用来做资源回收处理。
2. 多个 defer 语句，按先进后出顺序执行。
3. defer 语句中的变量，在 defer 声明时就决定了。
4. `return xxx`这条语句并不是一个原子指令，经过编译之后得到三条指令：1，返回值=xxx；2，调用 defer 函数；3，空的 return。因此要注意执行 defer 语句时是否改变了返回值。

### 循环

```go
for k,v range slice {
    ...
}
```

for range 表达式中参与循环的是 slice 的副本。slice 可能是数组，切片或 map，应注意数组的副本是另一个数组，切片的副本其指向的底层数组还是原来那个数组。

v 是 for 循环内的局部变量，是 slice 元素值的拷贝，而不是引用。

```go
for i := range slice {
    slice = append(slice, i)
}
```

上面代码中参与循环的是 slice 的副本，循环内改变 slice 长度不影响循环次数，因此不会出现死循环，能正常结束。

### init 函数及包初始化

init 函数用于程序执行前进行包的初始化，比如初始化包里的变量等。

* 一个包甚至一个源文件中可以出现多个 init 函数。
* 同一个包中多个 init 函数，执行顺序：
  * 如果多个 init 函数在不同的源文件中，则按源文件名以字典序从小到大排序，小的先被执行。准确来说，应是按提交给编译器的源文件名顺序为准，只是在提交编译器之前，go 命令行工具对源文件名按字典序排序了。
  * 同一包且同一源文件中的 init 函数，则按其出现在文件中的先后顺序依次初始化。
* 不同包 init 函数的执行顺序由包导入的依赖关系决定，从依赖的最顶层到最底层。
* init 函数在代码中不能被显示调用，也不能被引用。

包的初始化：

* 包的初始化顺序由包导入的依赖关系决定，从依赖的最顶层到最底层。
* 一个包被引用多次也只初始化一次。
* 不可出现循环导包。解决循环导包的常见思路：todo

同一 go 文件：

* 初始化顺序： (1) 导入的包； (2) 当前包中的变量常量； (3) 当前包的 init 函数； (4) main 函数。
* 包级别变量常量按其出现在文件中的先后顺序依次初始化。还有一大原则就是被引用的先初始化，比如某个变量需要依赖其他变量，则被依赖的变量先初始化。

![image-20210224143401133](go中文网题目笔记.assets/image-20210224143401133.png)

### 值类型和引用类型变量

值类型：基本数据类型 int、float、bool、string 以及数组和 struct。值类型变量直接存储值，内存通常在栈中分配。

引用类型：指针、slice、map、chan、interface、function。引用类型变量存储的是一个地址，这个地址存储最终的值，内存通常在堆上分配，通过 GC 回收。引用类型都可以用nil进行赋值

### 指针和引用

todo

指针是用来存储变量地址的类型，用星号加上数据类型表示。

相同：

* 都用来让一个变量提供对另一个变量的访问。Java 支持引用。

不同：

* 指针变量存储的是另一个变量的地址。引用变量指向另一个变量。
* 指针可以重新分配，而引用不能。

go 语言中引用类型变量打印出来是一个地址。

```go
// 测试

```

### ... 的使用

1. 定义可变参数函数

   ```go
   func change(str string, s ...string) {
       fmt.Printf("%T\n",s)
       fmt.Println(s)
   }
   ```

2. 切片作为函数的可变参数

   ```go
   var a = []int{1,2,3}
   change("b", a...)
   ```

3. 数组定义

   ```go
   var arr = [...]int{1,2,3,4,5}
   ```

   编译器会自动确定数组长度。

### goroutine

见《goroutine与并发编程.md》

### select 使用

见《goroutine与并发编程.md》

### context 使用

定义，原理：todo

使用场景：超时控制，保存全局信息。

使用方法

### 声明和赋值问题

* 单变量声明

  如`x := 1`，用于声明之前未声明过的变量 x，并赋值为 1。

* 多变量声明

  如`x, y := 1, 2`，左边的变量有一个是未声明过的就可以。如果变量 x 与同名已定义的变量 x 不在同一个作用域中，那么 go 会重新定义这个变量。

* 结构体字段不能声明

  `data.result, err := work()`出错

  := 操作符不能用于结构体字段声明，应修改为赋值的方式

  ```go
  var err error
  data.result, err = work()
  ```

* 被赋值变量可取址

  对于类似`x = y`的赋值操作，必须知道 x 的地址，才能够将 y 的值赋给 x。map 的 value 不可寻址，所以不能赋值。

* 多重赋值

  ````go
  var i, j int
  s := make([]string, 0)
  j = 1
  i，s[j-1] = 1，"a" 
  ````

  最后一行分为两个步骤执行，有先后顺序：

  1. 计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式
  2. 赋值

  所以上面赋值实际先计算索引`j-1`的值，然后执行赋值操作`i, s[0] = 1, "s"`

* 字面量初始化数组、slice 和 map 时，最好是在每个元素后面加上逗号，即使是声明在一行或者多行都不会出错。

  ```go
  x := []int{1,2,}
  y := []int{
      1,
      2,
  }
  ```

### 常量

* 常量无法使用&取址。
* 常量声明组中如不指定类型和初始化值，则与上一行非空常量相同。
* iota
  * https://www.cnblogs.com/zsy/p/5370052.html
  * iota 是 go 语言中的常数计数器，只能在常量的表达式中使用。iota 在 const 关键字出现时将被重置为 0，const 中每新增一行常量声明将使 iota 计数一次。

### string、byte 和 rune

**string**

* go 语言中，字符串是只读的 byte 切片。
* string 类型变量的空值为 "" 。不能赋值为 nil，也不能判断是否等于 nil。

**byte**

 byte 是 uint8 的别名。常用来处理 ascii 字符。

**rune**

rune 是 go 的内置数据类型，是 int32 的别名，可表示的字符更多。常用来处理 unicode 或 utf-8 字符。在平时计算中文字符时，可用 rune。

**将 string 转成 rune 切片**

```go
s := "hello"
r := []rune(s) 
```

### 比较

* 不同类型不能进行比较。
* map、slice 和 function 属于不可比较类型，不能通过 == 比较，只能判断是否为 nil。
* map，slice 可以参考用 reflect.DeepEqual 方法来进行比较，经过反射操作，效率低。可自己实现。
* 数组长度是数组类型的一部分，不同长度的数组为不同类型，不能进行比较。
* 结构体比较
  * 结构体只能比较是否相等。
  * 结构体可比较的前提是所有成员变量的类型均可比较。
  * 相同类型的结构体才能进行比较。结构体类型是否相同不但与成员变量的类型有关，还与成员变量的顺序有关。
  * 如果结构体的所有成员都可以比较，可通过 == 或 != 比较是否相等，比较时逐项进行比较，如果每一项都相等，则两个结构体相等。

### nil 值问题

nil 只能赋值给引用类型的变量。

`var x = nil` 会导致编译错误，因为 nil 为上述类型的零值，如果不指定变量类型，编译器猜不出来变量的具体类型，导致编译错误。

### 代码编译合规规则

* 函数中声明的变量必须要使用，但可以有未使用的全局变量。函数的参数未使用也是可以的。
* 常量声明但未使用是能通过编译的，常量编译后是一个简单值的标识符。
* 导入的包如果未使用，代码不能通过编译。如果需要导入包又不想使用（只想执行包的初始化），可以用 `_ "fmt"` 使通过编译。
* 只有 `i++` 和`i--` 形式的自增自减，且只能作为独立语句，不能作为表达式。

### 反射

### go runtime

运行时

### go 编译

go 编译怎么从源码编译到二进制文件

### go build, go install 和 go get

* go build : 编译出可执行文件
* go install : go build + 把编译后的可执行文件放到 GOPATH/bin 目录下
* go get : git clone + go install

### 输入输出问题

- 如果某个类型实现了 String() 方法，当格式化输出的时候会自动使用 String() 方法。

- 格式化输出

  ```go
  i := -5
  fmt.printf("%+d", i)
  ```

  其中 %d 表示输出十进制数字，+ 表示输出数值的符号。

### 闭包

todo 

## 工程实践

go 命令

包管理，go mod 使用

如何调试一个 go 程序，线上问题排查、调优

slice 内存泄漏分析，go 内存逃逸分析

多小才是小对象，为什么小对象多了会造成 gc 压力

如何写单元测试和基准测试，什么是测试驱动开发

go 异常处理

go 错误处理

Sessions 和 Cookies

如何限流

websocket

长连接和短链接



go 语言中文网公众号 面试题 day61
19 锁失效，应该 data 指针作为 test() 的方法接收者



