# goroutine 与并发编程

Go 语言最大的特色就是从语言层面支持并发。通过轻量的 goroutines 和 channel 可以简便地处理并发问题。

## goroutine

goroutine 是 Go 语言实现的用户态线程，主要用来解决操作系统线程太“重”的问题。

#### 进程

进程通信需要利用各种模式的 IPC（进程间通信），如信号量，消息队列，管道等。

#### 线程

线程是可以在 OS 中执行的最小处理单元。

线程存在于某个进程中，进程可以包含多个线程。

线程之间共享内存。因此线程间通信比进程之间通信更加简单。

线程太“重”表现在一下两个方面：

1. 创建和切换太重：操作系统线程需要进入内核，而进入内核所消耗的性能开销较大。
2. 内存使用太重：内核在创建操作系统线程时为避免极端情况下操作系统线程栈的溢出，默认为其分配一个较大的栈内存，通常会导致浪费，且栈内存空间一旦创建和初始化之后大小不能改变，某些特殊场景下系统线程栈还是有溢出的风险。

线程变慢原因：

* 线程自身有一个很大的堆（大于等于1MB）占用了大量内存。
* 创建线程消耗太大。
* 线程需要重复存储许多寄存器，这会降低应用程序性能。
* 线程创建和消除是操作系统级别操作，这一操作较慢。

#### 协程

goroutine 并不是轻量级线程，它依赖于线程运行。goroutines 是 Golang 中执行并发任务的方式。他们仅存在于 go 运行时的虚拟空间中而不在于 OS 中，因此需要 go 调度器来管理他们的生命周期。要记住对于所有操作系统看到的都只有一个请求并运行多个线程的单个用户级进程。goroutine 由 GoRuntimeScheduler 管理。

为了使运行时的堆栈更小，新创建的 goroutine 只分配几 kb 的空间，如果不够，运行空间自动增长（或者缩小）内存来实现堆栈的管理，从而让大部分 goroutine 存在于适量的内存中。

#### 协程调度

MPG 调度模型，两级线程模型

M，P，G，Schedt 四个重要结构

https://segmentfault.com/a/1190000018150987

https://www.cnblogs.com/wdliu/p/9272220.html

#### 其他面试题

1. 什么是 goroutine；他与 process， thread 有什么区别；
2. goroutin 的调度，什么是抢占式goroutine调用；
3. 僵尸进程和孤儿进程；
4. 协程通信 channel，mutex
5. 怎样停止一个 goroutine，怎么实现协程完美退出

#### 面试总结版本

Go 语言通过轻量级的 goroutine 和 channel 来简便地处理并发问题，从语言层面支持并发。goroutine 是 Go 语言实现的用户态线程，主要用来解决操作系统线程太“重”的问题。

因为操作系统线程是内核层去操作的，性能开销大。且内核在创建操作系统线程的时候给其分配的内存较大且固定，造成浪费，极端情况下还有溢出风险。

相比于操作系统线程，goroutine 要轻量得多。goroutine 是用户态线程，存在于 Go 运行时的虚拟空间中而不在于 OS 中，通过 Go 调度器来管理他们的生命周期。其创建和切换都在用户代码中完成而无须进入操作系统内核，性能开销小。且 goroutine 启动时默认栈大小只有 2 kb，还可以动态扩大收缩，既避免浪费，又没有栈溢出风险。

所以 Go 程序中可以创建成千上万个 goroutine 并发执行任务而不用太担心性能和内存问题。

goroutine 建立在操作系统线程基础之上，它与操作系统线程之间实现了一个多对多 (M:N) 的两级线程模型。这里 M:N 指 M 个 goroutine 运行在 N 个操作系统线程之上，内核负责对这 N 个操作系统线程进行调度，而这 N 个系统线程又负责对这 M 个 goroutine 进行调度和运行。

所谓的对 goroutine 的调度，指程序代码按照一定算法在适当的时候选出合适的 goroutine 并放到 CPU 上去运行的过程，负责对 goroutine 进行调度的程序代码称之为 goroutine 调度器。

MPG 调度模型，两级线程模型

包含 M，P，G，schedt 四个重要结构

* G 结构体。保存了 goroutine 的所有信息，该结构体的每个实例都代表了一个 goroutine，调度器代码可以通过 G 对象来对 goroutine 进行调度。

* schedt 结构体。保存调度器自身的状态信息和 goroutine 的全局运行队列。每个 Go 程序只有一个调度器，即 schedt 结构体只有一个实例对象，该实例对象在源代码中被定义成了一个共享的全局变量，这样每个工作线程都可以访问它以及它的 goroutine 运行队列，我们成这个队列为全局运行队列。

* P 结构体。用于保存工作线程执行go代码时所必须的资源，goroutine 的运行队列等。即除全局运行队列外，每个工作线程有一个私有的局部 goroutine 运行队列，工作线程优先使用自己的局部运行队列，必要时才去访问全局运行队列，减少锁冲突，提高性能，提高工作线程的并发性。局部运行队列被包含在 P 结构体的实例对象之中，每一个运行着 go 代码的工作线程都会与一个 P 结构体的实例对象关联在一起。

* M 结构体。代表工作线程。每个工作线程都有唯一一个 M 结构体的实例对象与之对应，M 对象记录着工作线程的栈起始位置、当前正在执行的 goroutine 以及是否空闲等信息，还通过指针维持着和 P 结构体的实例对象之间的绑定关系。通过 M 可以找到与之对应的工作线程正在运行的 goroutine，还可以找到工作线程的局部运行队列等资源。

 ![image-20210224143444973](goroutine协程.assets/image-20210224143444973.png)

上图中圆形图案代表 g 结构体的实例对象，三角形代表 m 结构体的实例对象，正方形代表 p 结构体的实例对象，其中红色的 g 表示 m 对应的工作线程正在运行的 goroutine，而灰色的 g 表示处于运行队列之中正在等待被调度起来运行的 goroutine。

从上图可以看出，每个 m 都绑定了一个 p，每个 p 都有一个私有的本地 goroutine 队列，m 对应的线程从本地和全局 goroutine 队列中获取 goroutine 并运行之。

参考链接：

https://www.cnblogs.com/abozhang/p/10802319.html

## 并发编程

### 并行与并发

并行就是同时执行，在某一时间点能执行多个任务。并行需要借助多线程或多进程。

并发是在某一时间段内可以同时处理多个任务。通常说程序是并发设计的，就是说它允许多个任务同时执行，这个同时指的就是一段时间内。单线程中多个任务以间隔执行方式实现并发。

### 并发之协程 goroutine

协程（Goroutine）可以理解成轻量级的线程，Go 应用程序通常能并发地运行成千上万的协程。

#### 创建协程

Go 创建一个协程非常简单，只要在方法或函数调用之前加关键字 go 即可。

```go
func printHello() {
    fmt.Println("hello world goroutine")
}

func main() {
    go printHello()     // 创建协程
    go func() {			// 创建匿名协程
3        fmt.Println("hello world goroutine 2")
4    }()
    fmt.Println("main goroutine")
}
```

上面代码，使用 go 关键字创建了两个协程，因此现在包括主协程一共有三个协程。多个协程并发执行。主协程执行完毕，程序便退出，其他协程随即也退出。

### 并发之通道 channel

通道是协程之间通信的管道，从一端发送数据，另一端接收数据。

#### 声明

```go
var c chan int        // 声明了一个 nil 通道
c := make(chan int)   // 创建了一个可用通道，打印初始值是一个地址，类型是 chan int
```

#### 使用

一般将通道作为参数传递给函数或者方法实现两个协程之间通信。

对于无缓冲通道，通道操作默认是阻塞的，往通道里写数据之后当前协程便阻塞，直到其他协程将数据读出。一个协程被通道操作阻塞后，Go 调度器会去调用其他可用的协程，这样程序就不会一直阻塞。

#### 死锁

* 无缓冲通道只写数据或者读数据，当前协程阻塞，又没有其他可用的协程。
* 有缓冲通道已满，再往通道中写数据，当前协程阻塞，又没有其他可用的协程。
* 空 select 语句`select {}`，没有 case 分支，所以便一直阻塞引起死锁。

#### 关闭

可以用内置函数`close(ch)`关闭通道，通道关闭后数据不能再传输。

**判断通道已关闭**

* 数据接收方可以通过返回状态判断通道是否已关闭：

  ```go
  val, ok := <- ch
  ```

  ok 用于判断 ch 是否已关闭且没有缓冲值可以读取。为 true，该通道还可以进行读写操作；为 false，通道已关闭且没有缓冲数据，不能再进行数据传输，返回的对应类型的零值。

* for range 读取通道，通道关闭，for range 自动退出

  ```go
  for v := range ch {
  	fmt.Println(v)
  }
  ```

  应注意，使用 for range 读取一个通道，数据写入完毕后必须关闭通道，不然发生死锁。

#### 缓冲通道和通道容量

之前创建的通道是无缓冲的，读写通道会立马阻塞当前协程。对于缓冲通道，写不会阻塞当前通道直到通道满了，同理，读操作也不会阻塞当前通道除非通道没数据。

无缓冲的 channel 是同步的，而有缓冲的 channel 是异步的。

```go
ch := make(chan type, capacity)
```

capacity 是缓冲大小，必须大于 0。内置函数 len()、cap() 可以计算通道的长度和容量。

如果缓冲通道是关闭状态但有数据，仍然可以读取数据。

#### 单向通道

主要用在通道作为参数传递的时候，Go 提供了自动转化，双向转单向。

使用单向通道主要是可以提高程序的类型安全性，程序不容易出错。

#### 常见异常操作

* 往一个 nil channel 发送数据，会造成阻塞。

* 往一个 nil channel 接收数据，会造成阻塞。

  `v, ok := <-ch` ，如果 ch 的值为 nil，即使是两个返回值的形式，读取操作也是阻塞的。

* 往一个已经关闭的 channel 发送数据，会引起 panic。

* 从一个已经关闭的 channel 接收数据，返回已缓冲数据或者零值。

* 使用 for range 读取一个通道，数据写入完毕后必须关闭通道，不然发生死锁。

* 有方向的 channel 不可以被关闭。

### 并发之 select

#### 使用

select 的用法类似 switch，但 select 不会有输入值而且只用于通道操作。select 用于从多个发送或接收通道操作中进行选择。如果没有 default case，语句会阻塞直到其中有通道可以操作，如果有多个通道可以操作，会随机选择其中一个 case 执行。如果有 default case，select 语句不会阻塞，如果其他通道操作还没有准备好，将会直接执行 default 分支。

```go
select {
case s1 := <-ch1:
	fmt.Println(s1)
case s2 := <-ch2:
    fmt.Println(s2)
default:
    fmt.Println("no case ok")
}
```

case 分支中如果通道是 nil，该分支就会被忽略。

如果所有 case 空分支中的通道都是 nil，且没有 default case，就变成 select{} 语句。空 select 会阻塞协程，引起死锁。

#### 添加超时时间

有时候，我们不希望立即执行 default 语句，而是希望等待一段时间，若一段时间后还没有可操作的通道，则执行规定的语句。

```go
select {       // 会发送阻塞
case s1 := <-ch1:
    fmt.Println(s1)
case s2 := <-ch2:
    fmt.Println(s2)
case <-time.After(2*time.Second):     // 等待 2s
    fmt.Println("no case ok")
}
```

